# standard library for "make here" build scripts
#
# Normal usage pattern from a mkhere/xxx.sh
#
#	TARGET=xxx
#	. $(dirname "$0")/lib/stdlib


# Set debugging macros
if [ -n "$DEBUG" ]
then
	debug () { echo >&2 "$@"; }
else
	debug () { echo -n ''; }
fi

# Derive $TARGET and ensure its rootfs
TARGET=$(basename "$0")
TARGET=${TARGET%.sh}
VARIANT_TARGET="VARIANT_${TARGET}"
FLAVOUR_TARGET="FLAVOUR_${TARGET}"
if [ "$0" != "/mkhere/$TARGET.sh" ]
then
	NEWROOT=$(dirname "$0")/..
	debug Changing to build rootfs $NEWROOT
	# Following are useless, without export they don't seem to get here
	export $VARIANT_TARGET
	export $FLAVOUR_TARGET
	# Support for last command being "install"
	if [ "${!#}" = "install" ]
	then
		set -- "${@:1:$(($#-1))}"   # Drop last word from $@
		# Install after after running the command to form cpio archive
		chroot "$NEWROOT" /mkhere/$TARGET.sh "$@" | \
			cpio -i \
				--no-absolute-filenames \
				--make-directories \
				--unconditional \
				--quiet --verbose
		exit $?
	else
		# No install -- just run the command
		exec chroot "$NEWROOT" /mkhere/$TARGET.sh "$@"
	fi
fi

# Derive variables $VARIANT and $FLAVOUR
VARIANT=${!VARIANT_TARGET}
FLAVOUR=${!FLAVOUR_TARGET}
debug Script target is $TARGET, variant is $VARIANT, flavour is $FLAVOUR

# Derive DIR_SRC, DIR_GIT, DIR_BUILD, DIR_TREE and have them
DIR_FETCH=/dl/${TARGET}
DIR_SRC=/src/${TARGET}
DIR_GIT=${DIR_SRC}/${TARGET}.git
DIR_BUILD=/build/${TARGET}${VARIANT:+-${VARIANT}}
DIR_TREE=/tree/${TARGET}${VARIANT:+-${VARIANT}}
mkdir -p "${DIR_TREE}" "${DIR_BUILD}" "${DIR_SRC}" "${DIR_FETCH}"

# Strip the TRAILER last line for cpio archives
strip_cpio_trailer () {
	sed '$s/07070100000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000B00000000TRAILER!!!\(\x00\)*$//'
}

# Utility to erase a directory somewhat safely
empty_dir () {
	EMPTY_DIR=${1:-$PWD}
	case "$EMPTY_DIR" in
	"$DIR_TREE"|"$DIR_SRC"|"$DIR_BUILD"|"$DIR_TREE"|"$DIR_FETCH")
		rm -rf "$EMPTY_DIR/"*
		;;
	"$DIR_TREE"/*|"$DIR_SRC"/*|"$DIR_BUILD"/*|"$DIR_TREE"/*|"$DIR_FETCH"/*)
		rm -rf "$EMPTY_DIR"
		;;
	*)
		echo >&2 "Protecting you from: empty_dir \"$EMPTY_DIR\""
		exit 1
		;;
	esac
}

# Generic subcommand for installing dependencies
do_depend () {
	. $(dirname "$0")/lib/pkglib
	pkg_install $(do_dependencies)
}

# Generic do_tar, based on do_list
do_tar () {
	( cd "$DIR_TREE" ; tar -cf - $(do_list) )
}

# Generic do_tgz, based on do_tar, do_list
do_tgz () {
	do_tar | gzip --best
}

# Generic do_cpio, based on do_list
do_cpio () {
	do_list | ( cd "$DIR_TREE" ; cpio -o -H newc --quiet )
}

# Generic do_cpio, but without the TRAILER in the last line
do_cpioprefix () {
	do_cpio | strip_cpio_trailer
}

# Generic do_cpiogz, based on do_cpio, do_list
do_cpiogz () {
	do_cpio | gzip --best
}

# Generic do_cpiogz, but without the TRAILER in the last line
do_cpiogzprefix () {
	do_cpioprefix | gzip --best
}

# If not yet downloaded, fetch a first source code update
do_have () {
	if [ $(ls -1 "$DIR_SRC" | wc -l) -eq 0 ]
	then
		do_update
		do_depend
	fi
}

# Helper: Turn a list into a set by removing repeated entries (leave the first)
_mkset () {
	RETVAL=()
	for ELEM in "$@"
	do
		NEW=1
		for KNOWN in ${RETVAL[@]}
		do
			if [ "$ELEM" == "$KNOWN" ]
			then
				NEW=0
			fi
		done
		if [ $NEW -eq 1 ]
		then
			RETVAL+=( $ELEM )
		fi
	done
	echo ${RETVAL[@]}
}

# OS libraries from the build system that are needed for a package
do_oslibs () {
	LIBDIRS=$(
		cat /etc/ld.so.conf /etc/ld.so.conf.d/* | \
		sed -e 's/#.*$//' -e '/^[ \t]*$/d' -e '/^include[ \t].*/d'
	)
	# First, list all software (of the requested flavour)
	SWARE=( $( do_list ) )
	# Second, find linked libraries (dropping system-specific ones)
	REFLIBS=( $( _mkset $(
		for FILE in ${SWARE[@]}
		do
			if [ -f "$DIR_TREE/$FILE" -a -x "$DIR_TREE/$FILE" ]
			then
				ldd "$DIR_TREE/$FILE" | \
					sed \
						-e 's/^[ \t]*//' \
						-e 's/ .*//' \
						-e '/^linux-vdso\.so.*/d' \
						-e '/^[/]lib[/]ld-linux\.so.*/d' | \
					sort | uniq
			fi
		done
	) ) )
	# Third, mention external, and recurse on internal + external
	EXTREFS=()
	NEWREFS=()
	ADDREFS=( ${REFLIBS[@]} )
	REFLIBS=()
	while [ ${#ADDREFS[@]} -ne 0 ]
	do
		REFLIBS=( ${NEWREFS[@]} )
		NEWREFS=()
		for LIBNAME in ${ADDREFS[@]}
		do
			#TODO# Consider searching /tree for dependent pkgs too?
			for LIBFILE in $( find 2>/dev/null "$DIR_TREE" $LIBDIRS -follow -type f -name "$LIBNAME" )
			do
				#DEBUG# echo "Looking into $LIBNAME => $LIBFILE"
				case "$LIBFILE" in
				# References to our own package are installed,
				# but they may lead to further references in
				# the base system.  For this reason, do not
				# mention but traverse them recursively.
				$DIR_TREE/*)
					# echo >&2 DEBUG: Internal $LIBFILE
					NEWREFS+=( "$LIBNAME" )
					;;
				# References to other packages may be dropped.
				# It is understood that dependent libraries
				# will be installed by the caller anyway.
				# This is hoping that flavours will be okay.
				/tree/*)
					# echo >&2 DEBUG: Peer $LIBFILE
					;;
				# References to the base system are mentioned.
				# In addition, they may hold references to
				# other libraries in the base system.  For this
				# reason, traverse them recursively.
				*)
					# echo >&2 DEBUG: External $LIBFILE
					EXTREFS+=( "$LIBFILE" )
					NEWREFS+=( "$LIBNAME" )
					;;
				esac
			done
		done
		NEWREFS=( $( _mkset ${REFLIBS[@]} ${NEWREFS[@]} ) )
		ADDREFS=( ${NEWREFS[@]:${#REFLIBS[@]}} )
	done
	EXTREFS=( $( _mkset ${EXTREFS[@]} ) )
	# Fourth, resolve symbolic links by adding the referenced files
	ALLFILES=()
	for FILE in ${EXTREFS[@]}
	do
		echo "$FILE"
		# ls -l "$FILE"
		while [ -L "$FILE" ]
		do
			FILE=$(readlink -f "$FILE")
			echo "$FILE"
			# ls -l "$FILE"
		done
	done
}

# Construct a tar ball with os libs
#TODO# Maybe use this in a flavour, later on
do_oslibtar () {
	( cd / ; tar -cf - $(do_oslibs) )
}

# Construct a gzipped tar ball with os libs
do_oslibtgz () {
	do_oslibtar | gzip --best
}

# Construct a cpio archive with os libs (perhaps after cpioprefix)
do_oslibcpio () {
	( cd / ; do_oslibs | cpio -o -H newc --quiet )
}

# Construct a gzipped cpio archive with os libs (perhaps after cpioprefix)
do_oslibcpiogz () {
	do_oslibcpio | gzip --best
}

# Construct a cpio archive with os libs without TRAILER last line
do_oslibcpioprefix () {
	do_oslibcpio | strip_cpio_trailer
}

# Construct a gzipped cpio archive with os libs without TRAILER last line
do_oslibcpiogzprefix () {
	do_oslibcpioprefix | gzip --best
}

# Refuse to install with an intermediate command
do_install () {
	echo -n >&2 'You can only use "install" as a last command'
	exit 1
}


# Main programming, running the commands in argv[]
main_do_commands () {
	if [ "$#" -eq 0 ]
	then
		echo >&2 "Please supply one or more subcommands to $0"
		exit 1
	fi
	for TODO in "$@"
	do
		"do_$TODO"
		EXITCODE=$?
		if [ $EXITCODE -ne 0 ]
		then
			echo >&2 "$TARGET $TODO failed with exit code $EXITCODE"
			do_touch
			exit 1
		fi
	done
	debug "Success from subcommands $@"
}
